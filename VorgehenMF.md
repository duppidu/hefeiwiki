[Home](home)  
[Back](DokuSolidus)
***

## RefBox
Nachdem Ubuntu als System für die Refbox weggefallen ist haben wir uns aufs Fedora konzentriert. Wir installierten in der VirtualBox das aktuelle Fedora in der Version 21. Bei Fedora funktionierte die Installation der Refbox auf Anhieb. Auch das Installieren der benötigten Pakete ging einfacher, als bei Ubuntu. Fedora kommt standardmässig mit der GNOME-Oberfläche. Diese Oberfläche benötigt eher viele Leistungsressourcen und eine gut ausgestattete Oberfläche ist für die Refbox nicht nötig. Aus diesem Grund installierten wir die sehr Ressourcenfreundliche LXDE-Oberfläche. Wie uns bereits von Linux-Systemen bekannt ist, konnten wir wieder mit Widerstand kämpfen. Zuerst wurde die neue Oberfläche gar nicht erst gestartet. Dies konnte mit einer Anleitung aus dem Internet behoben werden. Nach dem erfolgreichen Start der neuen Oberfläche kam dann immer wieder ein OpenBox-Fehler. Dieser konnte wiederum mit Hilfe des Internets und dem Einfügen einer ellenlangen Codezeile behoben werden. 
Um nun noch Ressourcenfreundlicher zu Arbeiten war die Idee von Alain, den virtuellen Computer nur im Text-Modus zu starten. Das Problem war aber bisher, dass die Shell der Refbox eine Mindestgrösse des Bildschirmes bzw. der Konsole benötigt. Steht diese Mindestgrösse nicht zur Verfügung kann die Shell der Refbox erst gar nicht gestartet werden. In den Textmodus zu wechseln ist eine recht einfache Sache und gehört eigentlich zum Basiswissen eines Linux-Benützers. Das Problem ist das der Textmodus eine Standardauflösung hat, die gerade kleiner ist als die Mindestgrösse von der Shell der Refbox. Mit einer kurzen Suche im Internet fand sich aber eine fantastisch geniale Art diese Auflösung zu ändern. Dies funktionierte auch gleich von Anfang an. Es gab leider nur zwei Probleme. Das eine war das Starten der Refbox und der Shell. Das dies im Text-Modus funktioniert muss zuerst die Refbox als Hintergrundprozess gestartet werden und dann erst kann die Shell aufgerufen werden. Das andere war das die Anzeige nicht ganz korrekt ist. Eine Meldung ist so versetzt, dass sie die Anzeige auf der rechten Seite verdeckt. Bei einer grösser gewählten Auflösung ist die Anzeige korrekt, aber passte nicht mehr auf einen 13 Zoll Bildschirm. Aufgrund diesen zwei Problemen, wechselten wir wieder auf die, sowieso praktischere, grafische Oberfläche. 

### Kommunikation zur Refbox
Um die Funktion der Refbox zu testen wurde zuerst mit der ComRefBox-Klasse vom letzten Jahr eine Kommunikation zur Refbox aufgebaut. Dies funktionierte ohne Probleme. Danach ging es darum alles auf die neue RefBox-Version anzupassen. Ab da begann der lange Leidensweg mit Erfolgen gefolgt von Rückschlägen. 
#### Variable "local"
Bei einem Test fiel mir auf, das ich die Nachrichten bekomme, aber der Robotino erscheint nicht in der Liste der angehängten Roboter bei der Refbox. Ich verbrachte Stunden damit den Fehler zu suchen. Ein kleinen Lichtblick schenkte mir Wireshark. Dieses Programm kenne ich von meinem CCNA-Kurs her. Mit dem Programm kann der Netzwerkverkehr ausgelesen werden. Im Programm kann man den zu untersuchenden Adapter auswählen. Da die RefBox-Kommunikation über den "VirtualBox Host-Only Network"-Adapter läuft, kann der direkt im Programm so ausgewählt werden und nur die Nachrichten über diesen Adapter werden analysiert. So erhalte ich keine unnötigen Einträge aus dem Netzwerkverkehr des Computers. Bei der Analyse des Nachrichtenverkehrs kam immer wieder die Meldung "Port Destination unreachable". Ich konnte mir zuerst keinen Reim darauf machen und suchte fieberhaft weiter. Später fand ich die Lösung des Problems. 

Im Java-Programm haben sie letztes Jahr eine boolsche Abfrage programmiert. Mit dem Kommentar "if refbox on the same machine". Dies habe ich natürlich auf "false" gesetzt. Später fand ich heraus, dass das Fragezeichen und das Doppelpunkt bei der Verbindungsherstellung eine verkürzte "If else"-Abfrage ist. Mit einem "false" setzte es dann jeweils für das Senden und Empfangen der gleiche Port. Nachdem der Wert auf "true" gesetzt wurde, funktionierte die Verbindung wieder einwandfrei.
#### Protobuf-Compiler
Die Nachrichten stehen als .proto-Dateien im Programmverzeichnis der Refbox zur Verfügung. Um sie im Java zu benutzten müssen sie zuerst mit einem Java-Compiler in .java-Dateien kompiliert werden. Dieser Compiler kann von Google Developers heruntergeladen werden. Im Programmverzeichnis hat es jeweils Readme-Dateien, in denen sehr genau beschrieben ist, wie vorgegangen werden soll. Bei mir schlug allerdings der Kompiliervorgang unter Fedora fehl. Er hatte einen Syntaxfehler und wollte die Version des Protobuf, 2 oder 3, angegeben haben. Bei der Nachfrage für Hilfestellungen bekam ich dann direkt die fertig kompilierten Dateien. Später versuchte ich dennoch das Ganze unter Windows. Nach einigen Versuchen funktionierte dort der Kompiliervorgang.
#### Neue Potobuf-Files
Nach dem Einbinden der neuen Files gab das NetBeans unzählige Fehler aus. Zum einen wurde die Nachricht ExplorationMachine in Exploration Zone unbenannt. Durch das Ändern der betreffenden Zeilen konnten so bereits einige Fehler behoben werden. Die Anderen standen im Zusammenhang mit der Version der Protobuf Java Bibliothek. Es war noch die Version 2.5.0 eingebunden. Die neuen Protobuf-Files wurden aber mit der Compiler-Version 2.6.1 kompiliert. Deshalb musste die Version 2.5.0 aus dem Projekt entfernt und die Version 2.6.1 hinzugefügt werden. Danach zeigte NetBeans keine Fehler mehr. Ausser bei zwei Klassen "FakeRobot" und "MyFakeRobot". Dies sind nur Klassen zum Testen und werden nicht mehr benötigt. Deshalb habe ich sie aus dem Projekt gelöscht.
#### Protobuf_comm Bibliothek 
Nachdem ich die neuen Protobuf-Files eingebunden hatte, bekam ich später noch einmal die gleichen Meldung die noch einmal neu kompiliert wurden. Ich habe diese im NetBeans eingebunden und sonst noch einige Änderungen an der ComRefBox-Klasse für Testzwecke geändert. Beim nächsten Test, funktionierte dann die Kommunikation nicht mehr. Das Output zeigte keine Fehler, das Debuggen brachte mich auch nicht weiter. Das Programm geht jeweils tief in die verschiedenen Dateien. Das Einbinden der etwas älteren Protobuf-Files funktionierte nicht und auch nicht mit den Files und der Bibliothek vom letzten Jahr. Nach mehreren Stunden mit verzweifelten Tests, entfernte ich per Zufall die Protobuf_comm Bibliothek und versuchte eine erneute Verbindung. Die Kommunikation bestand sofort ohne weitere Probleme. Wie sich später herausstellte, beinhaltet die Protobuf_comm Bibliothek, alle Dateien und Meldungen vom letzten Jahr, welche aber bereits alle im Projekt implementiert sind. Das heisst manche Dateien waren durch die Einbindung dieser Bibliothek doppelt vorhanden. Das Programm hatte damit wohl ein Problem und NetBeans selber merkte dies aber nicht. Zudem wird diese Bibliothek auch nicht mehr weiterentwickelt. 
#### Neueste Version herunterladen
Die Version der Refbox mit der eine erfolgreiche Kommunikation hergestellt werden konnte, stammte aus dem Mai. Die aktuellste Version kann kompiliert werden und startet. Auch die Kommunikation funktioniert. Die angeschlossenen Roboter werden bei der Refbox nicht angezeigt. Zudem gibt es mit dem Git von FawkesRobotics ein Problem beim herunterladen der neusten Version über das Git.
## RobotinoOS
Die Möglichkeiten des Images haben sich bewährt. Obwohl das beim gegenwärtigen Image nach dem Aufspielen immer der Grub neu konfiguriert werden muss. Dadurch das drei Roboter nach China geschickt wurden und die zum Testen benötigten Robotinos dann gemietet worden sind, kam zu regen Wechseln der Robotinos. Aufgrund von Kommunikationsfehlern kam es zum Unglück, dass von einem gemieteten Roboter kein Sicherungsimage bei der Ankunft gemacht wurde. Jedenfalls konnte ich daraus ziehen, dass egal in welcher Situation ein System steht, vor Änderungen in Image gemacht werden muss. Da es bis jetzt so gut funktioniert ist der Zeitaufwand für das Image kleiner, als der Aufwand für gegenseitige Schuldzuweisungen.  
Einer der gemieteten Roboter war eine kleinere Version. Das heisst langsamerer Prozessor und vor allem eine kleinere Festplatte. Leider hat auch PartImage einen kleinen Haken. Das Image kann nur auf eine gleich grosse oder grössere Partition, als die Quellpartition des Images, gespielt werden. 

Für ein nächstes Mal sollte besser auch betrachtet werden, wie wahrscheinlich es ist, dass das Image auf einen kleineren Robotino geladen wird. Es wäre möglich die Partition zu verkleinern, ein Image zu erstellen und dann die Partition wieder zu vergrössern. Aktuell braucht das ganze System mit allen Programmen weniger als 10GB an Speicher. Müsste das Image doch auf eine grössere Partition, als die Quellpartition des Images, gespielt werden, so kann das Image problemlos aufgespielt werden. Danach kann die Partition mit GParted, welches ebenfalls auf der SystemRescueCD vorhanden ist, wieder vergrössert werden. Selber habe ich das nicht probiert, nach den Anleitungen und Foren im Internet sollte dies aber problemlos möglich sein.

## Laserscanner
Zuerst muss man sich im bestehenden Code schlau machen. Der ist leider sehr schlecht kommentiert, sodass das eher zeitaufwändig ist. Es sind viele einzelne Funktionen vorhanden, die aber alleine nicht viel bringen. So gibts jetzt eine neue Klasse [Laserscanner](Laserscanner). Darin sind alle Funktionen zusammen, welche für das verfahren und die Exploration nötig sind.  
## StateMachine
Da es unterschiedliche Spielphasen gibt (Setup, Exploration, Produktion), ist ein gesamtes Diagramm schwierig zu erstellen. Also wurden einzelne Diagramme zu den Spielphasen erstellt. Die Spielphasen wechseln sowieso unmittelbar nach der Meldung durch die Refbox. Nach dem erstellen der Diagramme für die Setupphase und für die Explorationsphase wird ein grobes Gerüst gemacht. Dieses besteht